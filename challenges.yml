## challenge template:
#
# <challenge_id>:
#   source?: link to source, if applicable
#   tags?:
#     - maths
#     - data_structures
#   difficulty?: trivial | easy | medium | hard | Industry_Standard | very_hard
#   template: |
#     // description of problem
#     function <fn_name>(arg1 /* type, properties */, arg2 ...) {
#
#     }
#   sample_solution: |
#     function <fn_name>(<args>) {
#       solution of problem that is meant to pass all tests.
#       This is mostly to make sure you didn't make a mistake in the tests
#     }
#   recommended_time_ms: time in ms in which you should try to finish the challenge
#   tests:
#     <suite>: # usually one of correctness/edge_cases/performance
#       <name>:
#         # set if you want the user to see the test before submitting the challenge
#         visible?: true
#
#         # a string to eval into the arguments for the test.
#         # Sometimes an array works, but it will be coerced into a string
#         args: 1, 2
#
#         # result. Might get turned into a string. We compare the `JSON.stringify` version
#         # of the received output with this, using `==`
#         res: 2
#
#         # set if `res` is numeric, to account for floating point errors.
#         # The test will pass if received output is within `delta/2` of `res`.
#         # You can set it to the default of 0 if you want precise results
#         delta?: 1e-5
#
#         # Every test is 1 point by default, and the final score is the achieved points
#         # divided by the maximum achievable points. Preferrably make similar tests of the
#         # same type, scored at 1, instead of assigning a higher score to a single test.
#         score?: 2
#
#         # If this is set, the test will be benchmarked, and the test will fail if the average
#         # runtime is bigger than this property.
#         # Benchmarks only run for 500ms, so having a time higher than that will be pointless.
#         # The performance depends on the user's machine, so allow plenty of leeway. It should be
#         # about testing cyclomatic complexity
#         max_time_ms?: 10

add:
  source: testing sample
  tags:
    - maths
  difficulty: trivial
  fn_name: add
  template: |
    function add(a, b) {
      // add a and b
    }
  sample_solution: |
    function add(a, b) { return a + b }
  recommended_time_ms: 60e3 # 1 min
  tests:
    correctness:
      small_int:
        visible: true
        args: 1, 1
        res: 2
      small_float:
        args: 1.1, 0.1
        res: 1.2
        delta: 1e-3
    edge_cases:
      neg_and_pos: 
        args: '-1, 1'
        res: 0
        score: 3
    performance:
      small_int:
        visible: true
        args: 1, 1
        res: 2
        max_time_ms: 10
      big_int:
        visible: true
        args: 10000, 20000
        res: 30000
        max_time_ms: 25
      huge_int:
        args: 1e10, 2e10
        res: 3e10
        max_time_ms: 100
parens-count:
  source: modified from https://adventofcode.com/2015/day/1
  difficulty: trivial
  fn_name: count
  template: |
    // You're given a string of characters, some of which are `()`.
    //
    // Starting at 0, the state should
    // - increment by 1 when you encounter a `(`
    // - decrement by 1 when you encounter a `)`
    //
    // The state is not bound.
    //
    // Return the state at the end of the string.
    function count(parens /* string, length <= 20 */) {
      
    }
  sample_solution: |
    function count(parens) {
      let state = 0;
      for (const char of parens) {
        if (char === '(') state += 1;
        else if (char === ')') state -= 1;
      }
      return state;
    }
  recommended_time_ms: 180e3 # 3 min
  tests:
    correctness:
      one_up:
        visible: true
        args: '"("'
        res: 1
      one_down:
        visible: true
        args: '")"'
        res: -1
      one_up_down:
        visible: true
        args: '"()"'
        res: 0
      one_down_up:
        args: '")("'
        res: 0
      all_up:
        args: '"(((((((((((((((((((("'
        res: 20
      all_down:
        args: '"))))))))))))))))))))"'
        res: -20
      random_5char:
        args: '"()(()"'
        res: 1
      random_10char:
        args: '"())(()()))"'
        res: -2
      random_20char:
        args: '"())(()()))(((()()()("'
        res: 2
    edge_cases:
      empty:
        visible: true
        args: "''"
        res: 0
      mixed_chars:
        args: '"(hi)"'
        res: 0
      mixed_chars_start:
        args: '"("'
        res: 1
      mixed_chars_end:
        args: '")hi"'
        res: -1
    performance:
      random_20char:
        args: '"())(()()))(((()()()("'
        res: 2
        max_time_ms: 2
        score: 3
visit-cells:
  source: modified https://adventofcode.com/2015/day/3
  tags:
    - data_structures
  difficulty: easy
  fn_name: countVisitedCells
  template: |
    // A cursor is traversing an infinite two-dimensional grid of cells
    //
    // It first visits the cell at the starting location, then reads the next character and
    // moves by one cell accordingly: up (^), down (v), right (>), or left (<).
    // 
    // The function should return the number of cells visited *at least* once
    // 
    // For example:
    //  - `>` visits 2 cells: one at the starting location, and one to the right.
    //  - `^>v<` visits 4 cells in a square, visiting the starting/ending location twice.
    //  - `^v^v^v^v^v` visits 2 cells, repeatedly.

    function countVisitedCells(instructions /* string, length <= 1000 */) {

    }
  sample_solution: |
    function countVisitedCells(instructions /* string, length <= 1000 */) {
      const cursor = {x:0, y:0};
      const cells = new Set();
      const addCell = () => cells.add(cursor.x + ',' + cursor.y);

      addCell();
      for (const char of instructions) {
        switch (char) {
          case '>': cursor.x += 1; break;
          case '<': cursor.x -= 1; break;
          case 'v': cursor.y += 1; break;
          case '^': cursor.y -= 1; break;
        }
        addCell();
      }

      return cells.size;
    }
  recommended_time_ms: 240e3 # 4 minutes
  tests:
    correctness:
      right:
        visible: true
        args: '">"'
        res: 2
      left:
        args: '"<"'
        res: 2
      up:
        args: '"^"'
        res: 2
      down:
        args: '"v"'
        res: 2
      right_2:
        visible: true
        args: '">>"'
        res: 3
      square:
        visible: true
        args: '"^>v<"'
        res: 4
      vertical_zigzag:
        visible: true
        args: '"^v^v^v^v^v"'
        res: 2
      random_20char:
        # Array(20).fill(0).map(x => 'v^<>'[Math.random() * 4 |0]).join('')
        args: '">>v><v<^v^v>^>^<v<<v"'
        res: 11
      random_100char:
        # Array(100).fill(0).map(x => 'v^<>'[Math.random() * 4 |0]).join('')
        args: '"^<^vvv^<<^>^v>^<v^><<vv<v^vvv^^v<v<v>^^vv<<^><^v>>v^<^<vv^<^>^>v>>>>>^v^vv>>><^^vv<>^v^v<>v>v^><>^^v"'
        res: 44
      random_1000char:
        args: '"v<><^>>^<v>^v<vvv>><>^v<>^><>^<v>>vvv<^^^v<^^>>v><>^><>^v^v><<>>>v><>^>>><v^^v>^^<v>>>^v^v^^^>vvvvv^^>>>v>>^^v>v<^^vv^v>^<>v><v>^^^<^<^<><>v^vv<><^<^^^v<>^>v^>^>^v<v<^v><v<>^v<v><>vvv<^v>v<<>^><<<<^vv<v><^<^v>v>><^^<^^vvv<<v><v<<<<v>^<<^^>v>v^v^v<^><v^v<^vv><v^^>^^<v<>>><<>><>^v>>v<<v<^<<^>v>^><^<>v^^v<^<<v^<v>>v^v^<<v<^^<<^<v><^>^v^<v<^<v^v^><<v^v<<v<><^v<<^><>^<<v<^<^^><v<v>v^><<>^><>^<<v<^<^v>v^>v>>>vv>v^v>><<^^>vv>vvvv^><<><><>^<<^>>v><^<v<>>>^v^<><<^><<<>><v>^<v^>^vvv^>>v<^v>v>^^<>^v^v^v>v>v^^<>><><<^<v>>^>v<<^><><vvvv^vv>vv>vv>vvv<^<>v<><<>v>>^<<^<<<^<>^^><^^>>>v<^^vvvv><^v<>^>>v>^<v>^>v><v><>^<<^^^^>^^v^><<^^^<>^v><<<^<v^><>^^^><>>v<<^v>^<^^^vv><>v>>><<^><^^^<><vvvv^<vv^>>^<v<<^>vvv<>>vvv>v>>v<^<<<vv<v^^^^<>^<^<>^^>^^<>>v>v><v<v><<<vv><<>>>>^>^v<v>^v<>v<<<v>>v><v<>v^>>><vvv^v^^>vv^v><<^^^><>^^v>v<<<>>vv>>>v^>^>v>><v>>>v^<v><vv>><v<><v<vvv^<>v^<>v>v<>vv>^^<>>v<>vv^^^>^^^>^v>^<<<<^v><v^^^^<>v^^vv>>vv^vv>^v^<v<^^>^^<^^^v^vv^vv<<^<><>><>v>><v^<^vvv>><^><v>>v<v<vv>^<v<^^>^vv<>vv<v^^^"'
        res: 335
    edge_cases:
      empty:
        args: '""'
        res: 1
      no_directions:
        args: '"hi"'
        res: 1
      mixed_directions:
        args: '"hvi"'
        res: 2
    performance:
      random_1000char:
        # Array(1000).fill(0).map(x => 'v^<>'[Math.random() * 4 |0]).join('')
        args: '"<v<><<^^v^><^><>^<v>>^^^>^><<<^v><^>>><><<<<<^<^<<vvv><>><<^^>><v>>^v<<^v<<>^vv>^>>v<<v^>>^^><<>v><vv<^^<vv^<vv^>^^<>v<^>v>v^<v>>^<<^^<>>^<v^vv>v>^>^^vvv^>^>^v>vvv>^vv<^<v<>><><^<>v^>v^>^^<>>>>^<>>>>>vv^>^>>^<<<^>^<>v<>v<v^^vvv^>>><vvv>^<^>^>v^^>v>^<>>v<><v^<v<<^^<<>>><^<<>><<^v<>^v^>>v>v^v<^^>^<>v^v>^<^>^>>>>>^<<v<^<><><v<>^vv^^^<vv<>vv^^>vv>^><v><>^<^^v^v^^<>v>><>v><v^^>^>>v><^^<vvv^^v>v<><^v^><<v^<<>^<v<><^v^<>v>^vv^>v^^vv^^<vv^v<><^<v>>vv^v<>v^<<^>>^<^><vv<^^^^>v>vv<>v<v<<>vvvvv>>^<<v>>vv<^^<^<>>^<v<<^^><>>^<v<vvv<<v^^^v>^<^><v^<v^^vv><v<v>^>>v<vvv^<<>>^v^<^^^v^>^^<^^^<<^<><^v<>vv^^v>v^<<^^>^v>^<<^v>^v<^^<v>v>^v>^>>>>><^^<>^^>>v<^<<^>^^<<>>^v>vvv<vv^<<^<<^vv>v^vv^^^>>v^^<><v^>v<<^<<v^v>v>>^>^<<<>^<v><<<v<><^<v^^>^v>>^^^v<^^^<v^v<^<v<<>^^<>vv>^v>v>v<^>>vv<<^>v>^^vv^>^v>>^>v><<^vvvv>><^v^^>^^v><^<^<>><vv^^<<vv^v><^<>v><>^>^>^v^<<<v^>>vvv<<^v<v><^>>v<<<v>>v^>v<vv^^v>^^<^^v<v^v<v<<>v><v<<>v<>v<>>^>v^vvv^><^>v<<>>>v<><><^vv><^v^^^v^v^<^<>^><^>v>^v^>^v^^vvv<>^v<<<^^^^^vv^>v^^>^^><<vv^^>^"'
        res: 295
        max_time_ms: 0.4 # sample sol is 0.08ms on a fast machine
        score: 3
shortest-distance:
  source: modified https://adventofcode.com/2015/day/9 (part 1)
  tags:
    - maths
    - data_structures
  difficulty: Industry Standard
  fn_name: shortestDistance
  recommended_time_ms: 1800e3 # 30 min
  template: |
    // Given a string containing distances on each line, of the form:
    //   ABC to XYZ = 123
    // return the shortest path between all nodes, as a number.
    //
    // You cannot visit the same node twice (by design, it won't lead to shorter routes).
    // You may start and end at any node.
    // The distance ABC to XYZ is the same as XYZ to ABC.
    // If a distance is not specified, there's no direct route between the nodes.
    // It is guaranteed that there is a valid path.
    //
    // e.g. given the string:
    //   London to Dublin = 464
    //   London to Belfast = 518
    //   Dublin to Belfast = 141
    // the shortest path to visit all of London, Dublin, and Belfast is
    //   London -> Dublin -> Belfast
    //         464   +    141
    // so you should return
    //   605
    //
    // The node names are always made up of only ascii letters,
    // and the distances are always integers below 1000.
    // There are at most 8 nodes.

    function shortestDistance(distances /* string, lines <= 30 */) {

    }
  sample_solution: |
    function shortestDistance(distances /* string, max lines = 30 */) {
      if (distances.length === 0) {
        return 0;
      }

      const dists = {};
      const nodeSet = new Set();
      for (const line of distances.split('\n')) {
        // `\x20` = space. Using a space messed up syntax highlighting in yaml
        const [a, /* to */, b, /* = */, distStr] = line.split('\x20');
        const dist = Number(distStr);

        if (!dists[a]) {
          dists[a] = {};
        }
        dists[a][b] = dist;

        if (!dists[b]) {
          dists[b] = {};
        }
        dists[b][a] = dist;

        nodeSet.add(a);
        nodeSet.add(b);
      }

      const nodes = Array.from(nodeSet);
      const permutations = getPermutations(nodes);

      let shortest = Infinity;
      perms: for (const perm of permutations) {
        let path = 0;

        for (let i = 0; i < perm.length - 1; ++i) {
          const a = perm[i];
          const b = perm[i+1];

          const dist = dists[a][b];

          if (dist === undefined) continue perms;

          path += dist;

          if (path >= shortest) {
            continue perms;
          }
        }

        shortest = path;
      }

      return shortest;
    }
    // https://stackoverflow.com/a/43260158/3161092
    function getPermutations(xs) {
      let ret = [];

      for (let i = 0; i < xs.length; i = i + 1) {
        let rest = getPermutations(xs.slice(0, i).concat(xs.slice(i + 1)));

        if(!rest.length) {
          ret.push([xs[i]])
        } else {
          for(let j = 0; j < rest.length; j = j + 1) {
            ret.push([xs[i]].concat(rest[j]))
          }
        }
      }
      return ret;
    }
  tests:
    correctness:
      2_linear:
        args: "'x to y = 6'"
        res: 6
      3_linear:
        args: |
          `X to Y = 3
          Y to Z = 2`
        res: 5
      3_linear_with_inversion:
        args: |
          `X to Y = 3
          Z to Y = 2`
        res: 5
      3_linear_with_reduntant:
        visible: true
        args: |
          `London to Dublin = 464
          London to Belfast = 518
          Dublin to Belfast = 141`
        res: 605
      8_linear:
        args: |
          `a to b = 1
          b to c = 2
          c to d = 3
          d to e = 4
          e to f = 5
          f to g = 6
          g to h = 7
          h to i = 8`
        res: 36
      7_with_28_connections:
        args: |
          `Tristram to AlphaCentauri = 34
          Tristram to Snowdin = 100
          Tristram to Tambi = 63
          Tristram to Faerun = 108
          Tristram to Norrath = 111
          Tristram to Straylight = 89
          Tristram to Arbre = 132
          AlphaCentauri to Snowdin = 4
          AlphaCentauri to Tambi = 79
          AlphaCentauri to Faerun = 44
          AlphaCentauri to Norrath = 147
          AlphaCentauri to Straylight = 133
          AlphaCentauri to Arbre = 74
          Snowdin to Tambi = 105
          Snowdin to Faerun = 95
          Snowdin to Norrath = 48
          Snowdin to Straylight = 88
          Snowdin to Arbre = 7
          Tambi to Faerun = 68
          Tambi to Norrath = 134
          Tambi to Straylight = 107
          Tambi to Arbre = 40
          Faerun to Norrath = 11
          Faerun to Straylight = 66
          Faerun to Arbre = 144
          Norrath to Straylight = 115
          Norrath to Arbre = 135
          Straylight to Arbre = 127`
        res: 251
        score: 3
    edge_cases:
      empty:
        args: "''"
        res: 0
      8_linear_with_shorter_loop:
        args: |
          `a to b = 20
          b to c = 2
          c to d = 3
          d to e = 4
          e to f = 5
          f to g = 6
          g to h = 7
          h to i = 8
          i to a = 1`
        res: 36
      8_linear_with_inversions:
        args: |
          `b to a = 1
          b to c = 2
          d to c = 3
          d to e = 4
          f to e = 5
          f to g = 6
          h to g = 7
          h to i = 8`
        res: 36
    performance:
      3_linear_with_inversions:
        args: |
          `London to Dublin = 464
          London to Belfast = 518
          Dublin to Belfast = 141`
        res: 605
        max_time_ms: 3
      7_with_28_connections:
        args: |
          `Tristram to AlphaCentauri = 34
          Tristram to Snowdin = 100
          Tristram to Tambi = 63
          Tristram to Faerun = 108
          Tristram to Norrath = 111
          Tristram to Straylight = 89
          Tristram to Arbre = 132
          AlphaCentauri to Snowdin = 4
          AlphaCentauri to Tambi = 79
          AlphaCentauri to Faerun = 44
          AlphaCentauri to Norrath = 147
          AlphaCentauri to Straylight = 133
          AlphaCentauri to Arbre = 74
          Snowdin to Tambi = 105
          Snowdin to Faerun = 95
          Snowdin to Norrath = 48
          Snowdin to Straylight = 88
          Snowdin to Arbre = 7
          Tambi to Faerun = 68
          Tambi to Norrath = 134
          Tambi to Straylight = 107
          Tambi to Arbre = 40
          Faerun to Norrath = 11
          Faerun to Straylight = 66
          Faerun to Arbre = 144
          Norrath to Straylight = 115
          Norrath to Arbre = 135
          Straylight to Arbre = 127`
        res: 251
        max_time_ms: 200 # 81ms on my machine
      8_linear_with_shorter_loop:
        args: |
          `a to b = 20
          b to c = 2
          c to d = 3
          d to e = 4
          e to f = 5
          f to g = 6
          g to h = 7
          h to i = 8
          i to a = 1`
        res: 36
        max_time_ms: 2000 # 814ms on my machine
look-and-say:
  source: modified https://adventofcode.com/2015/day/10
  tags:
    - strings
  difficulty: medium
  recommended_time_ms: 300e3 # 5min
  fn_name: lookAndSay
  template: |
    // A "look and say" iteration of a number generates a new number that is a compressed
    // form of reading the first number out loud.
    // Going through the first number from left to right, for each run of a digit, say the
    // count of those digits, and then the digit.
    //
    // For example:
    // - 1 becomes 11 ("one one", so 1 copy of digit 1)
    // - 11 becomes 21 ("two ones", so 2 copies of digit 1)
    // - 21 -> 1211 -> 111221 -> 312211
    // - 1111111111 -> 101 ("ten ones") -> 111011
    //
    // Given a sequence number and iteration number, return the length of the number you'd get by
    // applying the "look and say" iteration that number of times.

    function lookAndSay(
      sequence /* number, [0, Number.MAX_SAFE_INTEGER] */,
      iterations /* number, [0, 50] */,
    ) {
      
    }
  sample_solution: |
    function lookAndSay(
      sequence /* number, [0, Number.MAX_SAFE_INTEGER] */,
      iterations /* number, [0, 50] */,
    ) {
      let str = sequence.toString().split('');
      for (let i = 0; i < iterations; ++i) {
        str = iterate(str);
      }
      return str.length;
    }
    function iterate(str) {
      let res = [];

      let digit = str[0];
      let count = 0;
      for (const char of str) {
        if (char === digit) {
          count += 1;
        } else {
          res += count + '' + digit;
          digit = char;
          count = 1;
        }
      }
      res += count + '' + digit;
      return res;
    }
    
  tests:
    correctness:
      1,1:
        visible: true
        args: 1,1
        res: 2 # 11
      11,1:
        visible: true
        args: 11,1
        res: 2 # 21
      21,1:
        visible: true
        args: 21,1
        res: 4 # 1211
      1,3:
        visible: true
        args: 1,3
        res: 4 # 1211
      11,2:
        visible: true
        args: 11,2
        res: 4 # 1211
      1211,1:
        args: 1211,1
        res: 6 # 111221
      1234567890,1:
        args: 1234567890,1
        res: 20 # 11121314151617181910
        score: 3
      1113122113,40:
        args: 1113122113,40
        res: 360154
    edge_cases:
      0_iterations:
        args: 12345,0
        res: 5 # 12345
        score: 2
      more_than_9_runs:
        args: 1111111111,1
        res: 3 # 111
        score: 3
      max_int:
        args: 9007199254740991,1
        res: 26
        score: 2
      max_int,10:
        args: 9007199254740991,10
        res: 428
    performance:
      1,50:
        args: 1,50
        res: 1166642
        max_time_ms: 500 # 327 on my machine
        score: 4
      1113122113,50:
        args: 1113122113,50
        res: 5103798
        max_time_ms: 2000 # 1718 on my machine
        score: 2
robot-race:
  source: modified https://adventofcode.com/2015/day/14
  tags:
    - maths
  difficulty: Industry Standard # a lot of edge cases, and a simple major optimization
  recommended_time_ms: 1500e3 # 25min
  fn_name: winnerDistance
  template: |
    // You are in charge of the schedule for a massive upcoming robot race.
    // Your job is to find out the exact second that the race is going to end.
    //
    // At any point of the race, a robot is in a "go" or "stop" state.
    //
    // In the "go" state, the robot is moving towards the finish line at its constant `speed` (units/second).
    // In the "stop" state, the robot is not moving at all, and cooling down.
    //
    // They all start in the "go" state, but after `goTime` seconds, they switch to the "stop" state.
    // They will be in the "stop" state for `stopTime` seconds, and then go back to the "go" state.
    //
    // You are given these specs in a url encoded format. For example, a single robot would look like this:
    //
    //   speed=14&goTime=30&stopTime=127
    //
    // Each robot spec will be on a different line, and there is no guarantee of the order of the attributes.
    //
    // All the attributes are bound between 0 and 10000, including
    //
    // At what second (rounded up) will the winning robot have crossed the finish line?
    // Return `-1` if no robot will finish the race.

    function winnerDistance(specs /* string, lines <= 30 */, distance /* number, [0, 1_000_000_000] */) {
      
    }
  sample_solution: |
    function winnerDistance(specs /* string, lines <= 30 */, distance /* number, [0, 1_000_000_000] */) {
      if (distance === 0) {
        return 0;
      }

      const robots = specs.split('\n').map(l => {
        const robot = {};
        const s = l.split('&');
        for (const p of s) {
          const [name, value] = p.split('=');
          robot[name] = Number(value);
        }
        return robot;
      });

      let fastestTime = -1;
      for (const robot of robots) {
        const cycles = Math.floor(distance / (robot.speed * robot.goTime));
        const remainder = distance - (cycles * robot.speed * robot.goTime);

        if (!Number.isFinite(remainder)) {
          continue;
        }

        let time = cycles * (robot.goTime + robot.stopTime) + Math.ceil(remainder / robot.speed);
        if (remainder === 0) {
          time -= robot.stopTime;
        }

        if (!Number.isFinite(time)) {
          continue;
        }
        if (time >= 0 && (time < fastestTime || fastestTime === -1)) {
          fastestTime = time;
        }
      }

      return fastestTime;
    }
  tests:
    correctness:
      single_end_of_go:
        visible: true
        args: "'speed=14&goTime=30&stopTime=127', 420"
        res: 30
      single_end_of_go_plus_1:
        visible: true
        args: "'speed=14&goTime=30&stopTime=127', 421"
        res: 158 # goTime + stopTime + 1
      4_random_close:
        visible: true
        args: |
          `speed=14&goTime=30&stopTime=127
          speed=13&goTime=29&stopTime=127
          speed=1&goTime=10&stopTime=9
          speed=5&goTime=2&stopTime=3`, 1500
        res: 489
        score: 2
      30_random_varied:
        args: |
          `speed=1862&goTime=8039&stopTime=9950
          speed=7683&goTime=2081&stopTime=4102
          speed=9716&goTime=4001&stopTime=3274
          speed=3060&goTime=6277&stopTime=3746
          speed=3716&goTime=8957&stopTime=6862
          speed=6640&goTime=5209&stopTime=6801
          speed=9886&goTime=3857&stopTime=4818
          speed=1882&goTime=2656&stopTime=3875
          speed=4563&goTime=5285&stopTime=9807
          speed=8022&goTime=8171&stopTime=9104
          speed=9910&goTime=5138&stopTime=2252
          speed=2534&goTime=917&stopTime=5706
          speed=8204&goTime=8966&stopTime=7879
          speed=5824&goTime=64&stopTime=2457
          speed=5474&goTime=9227&stopTime=1244
          speed=2894&goTime=776&stopTime=2205
          speed=9045&goTime=1124&stopTime=7380
          speed=1841&goTime=6832&stopTime=8247
          speed=7712&goTime=6593&stopTime=8867
          speed=3268&goTime=5667&stopTime=2900
          speed=7831&goTime=4387&stopTime=3985
          speed=843&goTime=7817&stopTime=1849
          speed=7152&goTime=9659&stopTime=5755
          speed=2321&goTime=4848&stopTime=9793
          speed=8078&goTime=9531&stopTime=9040
          speed=8198&goTime=7863&stopTime=2138
          speed=4331&goTime=6834&stopTime=5645
          speed=3947&goTime=1812&stopTime=8427
          speed=7585&goTime=2816&stopTime=1259
          speed=4879&goTime=5709&stopTime=2611`, 100000
        res: 11
        score: 2
    edge_cases:
      no_full_cycle:
        args: "'speed=100&goTime=10&stopTime=127', 120"
        res: 2
      zero_distance:
        args: "'speed=14&goTime=30&stopTime=127', 0"
        res: 0
      unordered_specs:
        args: "'stopTime=127&speed=14&goTime=30', 420"
        res: 30
      zero_goTime:
        args: "'speed=14&goTime=0&stopTime=127', 1"
        res: -1
      zero_goTime_zero_distance:
        args: "'speed=14&goTime=0&stopTime=127', 0"
        res: 0
      zero_speed:
        args: "'speed=0&goTime=30&stopTime=127', 1"
        res: -1
      zero_speed_zero_distance:
        args: "'speed=0&goTime=30&stopTime=127', 0"
        res: 0
      zero_stopTime:
        args: "'speed=4&goTime=20&stopTime=0', 400"
        res: 100
    performance:
      single_long_distance:
        args: "'speed=2&goTime=5&stopTime=10', 1_000_000_000"
        res: 1499999990
        score: 6
        max_time_ms: 1 # 0.0019 on my machine, by doing maths
