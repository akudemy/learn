## challenge template:
#
# <challenge_id>:
#   source?: link to source, if applicable
#   tags?:
#     - maths
#     - data_structures
#   difficulty?: trivial | easy | medium | hard | Industry_Standard | very_hard
#   template: |
#     function <fn_name>(<args>) {
#       // description of problem
#     }
#   sample_solution: |
#     function <fn_name>(<args>) {
#       solution of problem that is meant to pass all tests.
#       This is mostly to make sure you didn't make a mistake in the tests
#     }
#   recommended_time_ms: time in ms in which you should try to finish the challenge
#   tests:
#     <suite>: # usually one of correctness/edge_cases/performance
#       <name>:
#         # set if you want the user to see the test before submitting the challenge
#         visible?: true
#
#         # a string to eval into the arguments for the test.
#         # Sometimes an array works, but it will be coerced into a string
#         args: 1, 2
#
#         # result. Might get turned into a string. We compare the `JSON.stringify` version
#         # of the received output with this, using `==`
#         res: 2
#
#         # set if `res` is numeric, to account for floating point errors.
#         # The test will pass if received output is within `delta/2` of `res`.
#         # You can set it to the default of 0 if you want precise results
#         delta?: 1e-5
#
#         # Every test is 1 point by default, and the final score is the achieved points
#         # divided by the maximum achievable points. Preferrably make similar tests of the
#         # same type, scored at 1, instead of assigning a higher score to a single test.
#         score?: 2
#
#         # If this is set, the test will be benchmarked, and the test will fail if the average
#         # runtime is bigger than this property.
#         # Benchmarks only run for 500ms, so having a time higher than that will be pointless.
#         # The performance depends on the user's machine, so allow plenty of leeway. It should be
#         # about testing cyclomatic complexity
#         max_time_ms?: 10

add:
  source: testing sample
  tags:
    - maths
  difficulty: trivial
  fn_name: add
  template: |
    function add(a, b) {
      // add a and b
    }
  sample_solution: |
    function add(a, b) { return a + b }
  recommended_time_ms: 60e3 # 1 min
  tests:
    correctness:
      small_int:
        visible: true
        args: 1, 1
        res: 2
      small_float:
        args: 1.1, 0.1
        res: 1.2
        delta: 1e-3
    edge_cases:
      neg_and_pos: 
        args: '-1, 1'
        res: 0
        score: 3
    performance:
      small_int:
        visible: true
        args: 1, 1
        res: 2
        max_time_ms: 10
      big_int:
        visible: true
        args: 10000, 20000
        res: 30000
        max_time_ms: 25
      huge_int:
        args: 1e10, 2e10
        res: 3e10
        max_time_ms: 100
parens-count:
  source: modified from https://adventofcode.com/2015/day/1
  difficulty: trivial
  fn_name: count
  template: |
    // You're given a string of characters, some of which are `()`.
    //
    // Starting at 0, the state should
    // - increment by 1 when you encounter a `(`
    // - decrement by 1 when you encounter a `)`
    //
    // The state is not bound.
    //
    // Return the state at the end of the string.
    function count(parens /* string, length <= 20 */) {
      
    }
  sample_solution: |
    function count(parens) {
      let state = 0;
      for (const char of parens) {
        if (char === '(') state += 1;
        else if (char === ')') state -= 1;
      }
      return state;
    }
  recommended_time_ms: 180e3 # 3 min
  tests:
    correctness:
      one_up:
        visible: true
        args: '"("'
        res: 1
      one_down:
        visible: true
        args: '")"'
        res: -1
      one_up_down:
        visible: true
        args: '"()"'
        res: 0
      one_down_up:
        args: '")("'
        res: 0
      all_up:
        args: '"(((((((((((((((((((("'
        res: 20
      all_down:
        args: '"))))))))))))))))))))"'
        res: -20
      random_5char:
        args: '"()(()"'
        res: 1
      random_10char:
        args: '"())(()()))"'
        res: -2
      random_20char:
        args: '"())(()()))(((()()()("'
        res: 2
    edge_cases:
      empty:
        visible: true
        args: "''"
        res: 0
      mixed_chars:
        args: '"(hi)"'
        res: 0
      mixed_chars_start:
        args: '"("'
        res: 1
      mixed_chars_end:
        args: '")hi"'
        res: -1
    performance:
      random_20char:
        args: '"())(()()))(((()()()("'
        res: 2
        max_time_ms: 2
        score: 3
visit-cells:
  source: modified https://adventofcode.com/2015/day/3
  tags:
    - data_structures
  difficulty: easy
  fn_name: countVisitedCells
  template: |
    // A cursor is traversing an infinite two-dimensional grid of cells
    //
    // It first visits the cell at the starting location, then reads the next character and
    // moves by one cell accordingly: up (^), down (v), right (>), or left (<).
    // 
    // The function should return the number of cells visited *at least* once
    // 
    // For example:
    //  - `>` visits 2 cells: one at the starting location, and one to the right.
    //  - `^>v<` visits 4 cells in a square, visiting the starting/ending location twice.
    //  - `^v^v^v^v^v` visits 2 cells, repeatedly.

    function countVisitedCells(instructions /* string, length <= 1000 */) {

    }
  sample_solution: |
    function countVisitedCells(instructions /* string, length <= 1000 */) {
      const cursor = {x:0, y:0};
      const cells = new Set();
      const addCell = () => cells.add(cursor.x + ',' + cursor.y);

      addCell();
      for (const char of instructions) {
        switch (char) {
          case '>': cursor.x += 1; break;
          case '<': cursor.x -= 1; break;
          case 'v': cursor.y += 1; break;
          case '^': cursor.y -= 1; break;
        }
        addCell();
      }

      return cells.size;
    }
  recommended_time_ms: 240e3 # 4 minutes
  tests:
    correctness:
      right:
        visible: true
        args: '">"'
        res: 2
      left:
        args: '"<"'
        res: 2
      up:
        args: '"^"'
        res: 2
      down:
        args: '"v"'
        res: 2
      right_2:
        visible: true
        args: '">>"'
        res: 3
      square:
        visible: true
        args: '"^>v<"'
        res: 4
      vertical_zigzag:
        visible: true
        args: '"^v^v^v^v^v"'
        res: 2
      random_20char:
        # Array(20).fill(0).map(x => 'v^<>'[Math.random() * 4 |0]).join('')
        args: '">>v><v<^v^v>^>^<v<<v"'
        res: 11
      random_100char:
        # Array(100).fill(0).map(x => 'v^<>'[Math.random() * 4 |0]).join('')
        args: '"^<^vvv^<<^>^v>^<v^><<vv<v^vvv^^v<v<v>^^vv<<^><^v>>v^<^<vv^<^>^>v>>>>>^v^vv>>><^^vv<>^v^v<>v>v^><>^^v"'
        res: 44
      random_1000char:
        args: '"v<><^>>^<v>^v<vvv>><>^v<>^><>^<v>>vvv<^^^v<^^>>v><>^><>^v^v><<>>>v><>^>>><v^^v>^^<v>>>^v^v^^^>vvvvv^^>>>v>>^^v>v<^^vv^v>^<>v><v>^^^<^<^<><>v^vv<><^<^^^v<>^>v^>^>^v<v<^v><v<>^v<v><>vvv<^v>v<<>^><<<<^vv<v><^<^v>v>><^^<^^vvv<<v><v<<<<v>^<<^^>v>v^v^v<^><v^v<^vv><v^^>^^<v<>>><<>><>^v>>v<<v<^<<^>v>^><^<>v^^v<^<<v^<v>>v^v^<<v<^^<<^<v><^>^v^<v<^<v^v^><<v^v<<v<><^v<<^><>^<<v<^<^^><v<v>v^><<>^><>^<<v<^<^v>v^>v>>>vv>v^v>><<^^>vv>vvvv^><<><><>^<<^>>v><^<v<>>>^v^<><<^><<<>><v>^<v^>^vvv^>>v<^v>v>^^<>^v^v^v>v>v^^<>><><<^<v>>^>v<<^><><vvvv^vv>vv>vv>vvv<^<>v<><<>v>>^<<^<<<^<>^^><^^>>>v<^^vvvv><^v<>^>>v>^<v>^>v><v><>^<<^^^^>^^v^><<^^^<>^v><<<^<v^><>^^^><>>v<<^v>^<^^^vv><>v>>><<^><^^^<><vvvv^<vv^>>^<v<<^>vvv<>>vvv>v>>v<^<<<vv<v^^^^<>^<^<>^^>^^<>>v>v><v<v><<<vv><<>>>>^>^v<v>^v<>v<<<v>>v><v<>v^>>><vvv^v^^>vv^v><<^^^><>^^v>v<<<>>vv>>>v^>^>v>><v>>>v^<v><vv>><v<><v<vvv^<>v^<>v>v<>vv>^^<>>v<>vv^^^>^^^>^v>^<<<<^v><v^^^^<>v^^vv>>vv^vv>^v^<v<^^>^^<^^^v^vv^vv<<^<><>><>v>><v^<^vvv>><^><v>>v<v<vv>^<v<^^>^vv<>vv<v^^^"'
        res: 335
    edge_cases:
      empty:
        args: '""'
        res: 1
      no_directions:
        args: '"hi"'
        res: 1
      mixed_directions:
        args: '"hvi"'
        res: 2
    performance:
      random_1000char:
        # Array(1000).fill(0).map(x => 'v^<>'[Math.random() * 4 |0]).join('')
        args: '"<v<><<^^v^><^><>^<v>>^^^>^><<<^v><^>>><><<<<<^<^<<vvv><>><<^^>><v>>^v<<^v<<>^vv>^>>v<<v^>>^^><<>v><vv<^^<vv^<vv^>^^<>v<^>v>v^<v>>^<<^^<>>^<v^vv>v>^>^^vvv^>^>^v>vvv>^vv<^<v<>><><^<>v^>v^>^^<>>>>^<>>>>>vv^>^>>^<<<^>^<>v<>v<v^^vvv^>>><vvv>^<^>^>v^^>v>^<>>v<><v^<v<<^^<<>>><^<<>><<^v<>^v^>>v>v^v<^^>^<>v^v>^<^>^>>>>>^<<v<^<><><v<>^vv^^^<vv<>vv^^>vv>^><v><>^<^^v^v^^<>v>><>v><v^^>^>>v><^^<vvv^^v>v<><^v^><<v^<<>^<v<><^v^<>v>^vv^>v^^vv^^<vv^v<><^<v>>vv^v<>v^<<^>>^<^><vv<^^^^>v>vv<>v<v<<>vvvvv>>^<<v>>vv<^^<^<>>^<v<<^^><>>^<v<vvv<<v^^^v>^<^><v^<v^^vv><v<v>^>>v<vvv^<<>>^v^<^^^v^>^^<^^^<<^<><^v<>vv^^v>v^<<^^>^v>^<<^v>^v<^^<v>v>^v>^>>>>><^^<>^^>>v<^<<^>^^<<>>^v>vvv<vv^<<^<<^vv>v^vv^^^>>v^^<><v^>v<<^<<v^v>v>>^>^<<<>^<v><<<v<><^<v^^>^v>>^^^v<^^^<v^v<^<v<<>^^<>vv>^v>v>v<^>>vv<<^>v>^^vv^>^v>>^>v><<^vvvv>><^v^^>^^v><^<^<>><vv^^<<vv^v><^<>v><>^>^>^v^<<<v^>>vvv<<^v<v><^>>v<<<v>>v^>v<vv^^v>^^<^^v<v^v<v<<>v><v<<>v<>v<>>^>v^vvv^><^>v<<>>>v<><><^vv><^v^^^v^v^<^<>^><^>v>^v^>^v^^vvv<>^v<<<^^^^^vv^>v^^>^^><<vv^^>^"'
        res: 295
        max_time_ms: 0.4 # sample sol is 0.08ms on a fast machine
        score: 3
shortest-distance:
  source: modified https://adventofcode.com/2015/day/9 (part 1)
  tags:
    - maths
    - data_structures
  difficulty: Industry Standard
  fn_name: shortestDistance
  recommended_time_ms: 1800e3 # 30 min
  template: |
    // Given a string containing distances on each line, of the form:
    //   ABC to XYZ = 123
    // return the shortest path between all nodes, as a number.
    //
    // You cannot visit the same node twice (by design, it won't lead to shorter routes).
    // You may start and end at any node.
    // The distance ABC to XYZ is the same as XYZ to ABC.
    // If a distance is not specified, there's no direct route between the nodes.
    // It is guaranteed that there is a valid path.
    //
    // e.g. given the string:
    //   London to Dublin = 464
    //   London to Belfast = 518
    //   Dublin to Belfast = 141
    // the shortest path to visit all of London, Dublin, and Belfast is
    //   London -> Dublin -> Belfast
    //         464   +    141
    // so you should return
    //   605
    //
    // The node names are always made up of only ascii letters,
    // and the distances are always integers below 1000.
    // There are at most 8 nodes.

    function shortestDistance(distances /* string, lines <= 30 */) {

    }
  sample_solution: |
    function shortestDistance(distances /* string, max lines = 30 */) {
      if (distances.length === 0) {
        return 0;
      }

      const dists = {};
      const nodeSet = new Set();
      for (const line of distances.split('\n')) {
        // `\x20` = space. Using a space messed up syntax highlighting in yaml
        const [a, /* to */, b, /* = */, distStr] = line.split('\x20');
        const dist = Number(distStr);

        if (!dists[a]) {
          dists[a] = {};
        }
        dists[a][b] = dist;

        if (!dists[b]) {
          dists[b] = {};
        }
        dists[b][a] = dist;

        nodeSet.add(a);
        nodeSet.add(b);
      }

      const nodes = Array.from(nodeSet);
      const permutations = getPermutations(nodes);

      let shortest = Infinity;
      perms: for (const perm of permutations) {
        let path = 0;

        for (let i = 0; i < perm.length - 1; ++i) {
          const a = perm[i];
          const b = perm[i+1];

          const dist = dists[a][b];

          if (dist === undefined) continue perms;

          path += dist;

          if (path >= shortest) {
            continue perms;
          }
        }

        shortest = path;
      }

      return shortest;
    }
    // https://stackoverflow.com/a/43260158/3161092
    function getPermutations(xs) {
      let ret = [];

      for (let i = 0; i < xs.length; i = i + 1) {
        let rest = getPermutations(xs.slice(0, i).concat(xs.slice(i + 1)));

        if(!rest.length) {
          ret.push([xs[i]])
        } else {
          for(let j = 0; j < rest.length; j = j + 1) {
            ret.push([xs[i]].concat(rest[j]))
          }
        }
      }
      return ret;
    }
  tests:
    correctness:
      2_linear:
        args: "'x to y = 6'"
        res: 6
      3_linear:
        args: |
          `X to Y = 3
          Y to Z = 2`
        res: 5
      3_linear_with_inversion:
        args: |
          `X to Y = 3
          Z to Y = 2`
        res: 5
      3_linear_with_reduntant:
        visible: true
        args: |
          `London to Dublin = 464
          London to Belfast = 518
          Dublin to Belfast = 141`
        res: 605
      8_linear:
        args: |
          `a to b = 1
          b to c = 2
          c to d = 3
          d to e = 4
          e to f = 5
          f to g = 6
          g to h = 7
          h to i = 8`
        res: 36
      7_with_28_connections:
        args: |
          `Tristram to AlphaCentauri = 34
          Tristram to Snowdin = 100
          Tristram to Tambi = 63
          Tristram to Faerun = 108
          Tristram to Norrath = 111
          Tristram to Straylight = 89
          Tristram to Arbre = 132
          AlphaCentauri to Snowdin = 4
          AlphaCentauri to Tambi = 79
          AlphaCentauri to Faerun = 44
          AlphaCentauri to Norrath = 147
          AlphaCentauri to Straylight = 133
          AlphaCentauri to Arbre = 74
          Snowdin to Tambi = 105
          Snowdin to Faerun = 95
          Snowdin to Norrath = 48
          Snowdin to Straylight = 88
          Snowdin to Arbre = 7
          Tambi to Faerun = 68
          Tambi to Norrath = 134
          Tambi to Straylight = 107
          Tambi to Arbre = 40
          Faerun to Norrath = 11
          Faerun to Straylight = 66
          Faerun to Arbre = 144
          Norrath to Straylight = 115
          Norrath to Arbre = 135
          Straylight to Arbre = 127`
        res: 251
        score: 3
    edge_cases:
      empty:
        args: "''"
        res: 0
      8_linear_with_shorter_loop:
        args: |
          `a to b = 20
          b to c = 2
          c to d = 3
          d to e = 4
          e to f = 5
          f to g = 6
          g to h = 7
          h to i = 8
          i to a = 1`
        res: 36
      8_linear_with_inversions:
        args: |
          `b to a = 1
          b to c = 2
          d to c = 3
          d to e = 4
          f to e = 5
          f to g = 6
          h to g = 7
          h to i = 8`
        res: 36
    performance:
      3_linear_with_inversions:
        args: |
          `London to Dublin = 464
          London to Belfast = 518
          Dublin to Belfast = 141`
        res: 605
        max_time_ms: 3
      7_with_28_connections:
        args: |
          `Tristram to AlphaCentauri = 34
          Tristram to Snowdin = 100
          Tristram to Tambi = 63
          Tristram to Faerun = 108
          Tristram to Norrath = 111
          Tristram to Straylight = 89
          Tristram to Arbre = 132
          AlphaCentauri to Snowdin = 4
          AlphaCentauri to Tambi = 79
          AlphaCentauri to Faerun = 44
          AlphaCentauri to Norrath = 147
          AlphaCentauri to Straylight = 133
          AlphaCentauri to Arbre = 74
          Snowdin to Tambi = 105
          Snowdin to Faerun = 95
          Snowdin to Norrath = 48
          Snowdin to Straylight = 88
          Snowdin to Arbre = 7
          Tambi to Faerun = 68
          Tambi to Norrath = 134
          Tambi to Straylight = 107
          Tambi to Arbre = 40
          Faerun to Norrath = 11
          Faerun to Straylight = 66
          Faerun to Arbre = 144
          Norrath to Straylight = 115
          Norrath to Arbre = 135
          Straylight to Arbre = 127`
        res: 251
        max_time_ms: 200 # 81ms on my machine
      8_linear_with_shorter_loop:
        args: |
          `a to b = 20
          b to c = 2
          c to d = 3
          d to e = 4
          e to f = 5
          f to g = 6
          g to h = 7
          h to i = 8
          i to a = 1`
        res: 36
        max_time_ms: 2000 # 814ms on my machine
